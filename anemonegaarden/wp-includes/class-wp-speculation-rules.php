<?php
 final class WP_Speculation_Rules implements JsonSerializable { private $rules_by_mode = array(); private static $mode_allowlist = array( 'prefetch' => true, 'prerender' => true, ); private static $eagerness_allowlist = array( 'immediate' => true, 'eager' => true, 'moderate' => true, 'conservative' => true, ); private static $source_allowlist = array( 'list' => true, 'document' => true, ); public function add_rule( string $mode, string $id, array $rule ): bool { if ( ! self::is_valid_mode( $mode ) ) { _doing_it_wrong( __METHOD__, sprintf( __( 'The value "%s" is not a valid speculation rules mode.' ), esc_html( $mode ) ), '6.8.0' ); return false; } if ( ! $this->is_valid_id( $id ) ) { _doing_it_wrong( __METHOD__, sprintf( __( 'The value "%s" is not a valid ID for a speculation rule.' ), esc_html( $id ) ), '6.8.0' ); return false; } if ( $this->has_rule( $mode, $id ) ) { _doing_it_wrong( __METHOD__, sprintf( __( 'A speculation rule with ID "%s" already exists.' ), esc_html( $id ) ), '6.8.0' ); return false; } if ( ( ! isset( $rule['where'] ) && ! isset( $rule['urls'] ) ) || ( isset( $rule['where'] ) && isset( $rule['urls'] ) ) ) { _doing_it_wrong( __METHOD__, sprintf( __( 'A speculation rule must include either a "%1$s" key or a "%2$s" key, but not both.' ), 'where', 'urls' ), '6.8.0' ); return false; } if ( isset( $rule['source'] ) ) { if ( ! self::is_valid_source( $rule['source'] ) ) { _doing_it_wrong( __METHOD__, sprintf( __( 'The value "%s" is not a valid source for a speculation rule.' ), esc_html( $rule['source'] ) ), '6.8.0' ); return false; } if ( 'list' === $rule['source'] && isset( $rule['where'] ) ) { _doing_it_wrong( __METHOD__, sprintf( __( 'A speculation rule of source "%1$s" must not include a "%2$s" key.' ), 'list', 'where' ), '6.8.0' ); return false; } if ( 'document' === $rule['source'] && isset( $rule['urls'] ) ) { _doing_it_wrong( __METHOD__, sprintf( __( 'A speculation rule of source "%1$s" must not include a "%2$s" key.' ), 'document', 'urls' ), '6.8.0' ); return false; } } if ( isset( $rule['eagerness'] ) ) { if ( ! self::is_valid_eagerness( $rule['eagerness'] ) ) { _doing_it_wrong( __METHOD__, sprintf( __( 'The value "%s" is not a valid eagerness for a speculation rule.' ), esc_html( $rule['eagerness'] ) ), '6.8.0' ); return false; } if ( isset( $rule['where'] ) && 'immediate' === $rule['eagerness'] ) { _doing_it_wrong( __METHOD__, sprintf( __( 'The eagerness value "%s" is forbidden for document-level speculation rules.' ), 'immediate' ), '6.8.0' ); return false; } } if ( ! isset( $this->rules_by_mode[ $mode ] ) ) { $this->rules_by_mode[ $mode ] = array(); } $this->rules_by_mode[ $mode ][ $id ] = $rule; return true; } public function has_rule( string $mode, string $id ): bool { return isset( $this->rules_by_mode[ $mode ][ $id ] ); } #[ReturnTypeWillChange]
 public function jsonSerialize() { return array_map( static function ( array $rules ) { return array_values( $rules ); }, array_filter( $this->rules_by_mode ) ); } private function is_valid_id( string $id ): bool { return (bool) preg_match( '/^[a-z][a-z0-9_-]+$/', $id ); } public static function is_valid_mode( string $mode ): bool { return isset( self::$mode_allowlist[ $mode ] ); } public static function is_valid_eagerness( string $eagerness ): bool { return isset( self::$eagerness_allowlist[ $eagerness ] ); } public static function is_valid_source( string $source ): bool { return isset( self::$source_allowlist[ $source ] ); } } 