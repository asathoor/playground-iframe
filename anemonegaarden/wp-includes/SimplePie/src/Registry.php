<?php
 declare(strict_types=1); namespace SimplePie; use InvalidArgumentException; use SimplePie\Content\Type\Sniffer; use SimplePie\Parse\Date; use SimplePie\XML\Declaration\Parser as DeclarationParser; class Registry { protected $default = [ Cache::class => Cache::class, Locator::class => Locator::class, Parser::class => Parser::class, File::class => File::class, Sanitize::class => Sanitize::class, Item::class => Item::class, Author::class => Author::class, Category::class => Category::class, Enclosure::class => Enclosure::class, Caption::class => Caption::class, Copyright::class => Copyright::class, Credit::class => Credit::class, Rating::class => Rating::class, Restriction::class => Restriction::class, Sniffer::class => Sniffer::class, Source::class => Source::class, Misc::class => Misc::class, DeclarationParser::class => DeclarationParser::class, Date::class => Date::class, ]; protected $classes = []; protected $legacy = []; private $legacyTypes = [ 'Cache' => Cache::class, 'Locator' => Locator::class, 'Parser' => Parser::class, 'File' => File::class, 'Sanitize' => Sanitize::class, 'Item' => Item::class, 'Author' => Author::class, 'Category' => Category::class, 'Enclosure' => Enclosure::class, 'Caption' => Caption::class, 'Copyright' => Copyright::class, 'Credit' => Credit::class, 'Rating' => Rating::class, 'Restriction' => Restriction::class, 'Content_Type_Sniffer' => Sniffer::class, 'Source' => Source::class, 'Misc' => Misc::class, 'XML_Declaration_Parser' => DeclarationParser::class, 'Parse_Date' => Date::class, ]; public function __construct() { } public function register(string $type, $class, bool $legacy = false) { if (array_key_exists($type, $this->legacyTypes)) { $type = $this->legacyTypes[$type]; } if (!array_key_exists($type, $this->default)) { return false; } if (!class_exists($class)) { return false; } $base_class = $this->default[$type]; if (!is_subclass_of($class, $base_class)) { return false; } $this->classes[$type] = $class; if ($legacy) { $this->legacy[] = $class; } return true; } public function get_class($type) { if (array_key_exists($type, $this->legacyTypes)) { $type = $this->legacyTypes[$type]; } if (!array_key_exists($type, $this->default)) { return null; } $class = $this->default[$type]; if (array_key_exists($type, $this->classes)) { $class = $this->classes[$type]; } return $class; } public function &create($type, array $parameters = []) { $class = $this->get_class($type); if ($class === null) { throw new InvalidArgumentException(sprintf( '%s(): Argument #1 ($type) "%s" not found in class list.', __METHOD__, $type ), 1); } if (!method_exists($class, '__construct')) { $instance = new $class(); } else { $reflector = new \ReflectionClass($class); $instance = $reflector->newInstanceArgs($parameters); } if ($instance instanceof RegistryAware) { $instance->set_registry($this); } elseif (method_exists($instance, 'set_registry')) { trigger_error(sprintf('Using the method "set_registry()" without implementing "%s" is deprecated since SimplePie 1.8.0, implement "%s" in "%s".', RegistryAware::class, RegistryAware::class, $class), \E_USER_DEPRECATED); $instance->set_registry($this); } return $instance; } public function &call($type, string $method, array $parameters = []) { $class = $this->get_class($type); if ($class === null) { throw new InvalidArgumentException(sprintf( '%s(): Argument #1 ($type) "%s" not found in class list.', __METHOD__, $type ), 1); } if (in_array($class, $this->legacy)) { switch ($type) { case Cache::class: if ($method === 'get_handler') { $result = @call_user_func_array([$class, 'create'], $parameters); return $result; } break; } } $callable = [$class, $method]; assert(is_callable($callable), 'For PHPstan'); $result = call_user_func_array($callable, $parameters); return $result; } } class_alias('SimplePie\Registry', 'SimplePie_Registry'); 